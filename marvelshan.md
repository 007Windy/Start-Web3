---
timezone: UTC+8
---


# Zaki

1. 自我介绍
  自己為一位小碼農，希望能跟大家一起進步
2. 你认为你会完成本次残酷学习吗？
  yes~

## Notes

<!-- Content_START -->

### 2025.03.05

從網際網路誕生至今，已經歷三次重要的變革，每次都深刻影響了我們的生活方式和社會結構。

### 1. Web 1.0時代（only讀網路）

這是網路的早期階段，網站只提供靜態資訊，使用者只能瀏覽和閱讀，無法參與互動。  
內容多為文字與圖片，網站由少數管理者控制，使用者純粹是「資訊接收者」。  
這就像一本電子版百科全書，網際網路是單純的知識來源。

---

### 2. Web 2.0時代（讀寫網路）

Web 2.0讓使用者能夠產生內容，開啟了雙向互動的新時代。  
部落格、社交媒體、影音平台興起，每個人都可以發布內容、留言互動、分享轉發。  
網路從單向資訊流，變成一個全球社群。但這些平台多數是中心化的，資料和流量掌握在少數科技巨頭手中，使用者的資料隱私和數據主權也因此受到威脅。

---

### 3. Web 3.0時代（去中心化網路）

Web 3.0以區塊鏈為基礎，強調去中心化與資料自主權。  
使用者真正擁有自己的數據，不再依賴單一平台。  
這個時代，網路上的價值傳遞不再需要中介，點對點的協作和創新將成為主流。  
Web 3.0被視為回歸網際網路的初衷：開放、自由、民主化。

---

### Web 2.0與Web 3.0的主要差異

| 項目 | Web 2.0 | Web 3.0 |
|---|---|---|
| **控制權** | 中心化，平台掌握一切 | 去中心化，使用者掌握資料 |
| **數據所有權** | 平台所有 | 使用者所有 |
| **互動模式** | 內容互動 | 透過智能合約直接互動 |
| **安全性** | 容易成為攻擊目標 | 分散式架構更安全透明 |
| **商業模式** | 廣告為主，賣數據 | 加密貨幣、代幣經濟、直接支付 |

---

### Web 3.0的額外補充與想像空間

1. **個人數位身份**  
   每個人在Web3.0中擁有獨一無二的去中心化身份（DID），登入、交易、簽署、社交，都不再需要依賴Google或Facebook。

2. **去中心化金融（DeFi）**  
   不再依賴銀行和金融機構，每個人都可以直接借貸、投資、交易。

3. **數位資產與NFT**  
   創作者的每件作品，都能在區塊鏈上紀錄來源與版權，價值可由市場透明定價。

4. **自治組織（DAO）**  
   每個人都可以參與或創建去中心化自治組織，透過代幣治理，社群一起決策發展方向。

5. **元宇宙融合**  
   Web3.0還可能與元宇宙深度結合，虛擬世界中的每筆資產、每次互動、甚至每場活動都將上鏈，形成真正屬於用戶的數位空間。


### 2025.03.06

#### 助記詞與私鑰的關係
助記詞和私鑰的本質都是「隨機數」，它們在功能上是一致的，都是用來掌控你的加密貨幣資產。

助記詞本質上也是一段 128～256 位的隨機數。由於直接使用隨機數或私鑰都太不方便，為了改善使用體驗，比特幣社群制定了 **BIP39** 協議，將隨機數透過特定的編碼方式，轉換為一組由詞庫中單詞組成的助記詞。

助記詞因為是常見的單詞，不區分大小寫，使用上比私鑰方便許多。這也是為什麼近年來，**助記詞錢包**已逐漸成為主流。

#### 助記詞的優勢
助記詞錢包還有一個重要優點：  
**一組助記詞可以派生出無數個私鑰，每個私鑰可以對應不同幣種。**  
換句話說，如果你持有 30 種加密貨幣（如 BTC、ETH、LTC、EOS等），只要保存一組助記詞，就能掌控所有資產，不需要每種幣都單獨備份私鑰。

像「比特派錢包」，會同時展示助記詞和私鑰給用戶，但一般情況下，**只要妥善備份助記詞**就足夠了。

#### 助記詞是否通用？
只要各個錢包都遵循 **BIP32、BIP39、BIP44** 標準協議，助記詞就是通用的，理論上可以在不同錢包之間導入和恢復資產。  
**但要注意，不同錢包的安全性和實作細節有所不同，所以不建議頻繁跨錢包導入助記詞。**

---

### BIP 協議詳細介紹

#### BIP32：分層確定性錢包（Hierarchical Deterministic Wallet）
- BIP32 定義了一種「分層結構」的錢包，讓一組「主私鑰」可以派生出無限多個子私鑰，這樣你可以為每個幣種、每筆交易生成不同的地址，提升隱私性。
- BIP32 還允許透過「公開鍵」直接推算子地址（觀察錢包的概念），讓第三方（如會計師或稅務機構）可以監控地址資金流動，卻無法掌控資產。

#### BIP39：助記詞生成與管理（Mnemonic Phrase）
- BIP39 定義了如何把隨機數轉換成一組「助記詞」，並確保這組助記詞可以轉回原始隨機數。
- 助記詞來自固定的詞庫（如 2048 個英文單詞），加上校驗機制，讓輸入錯誤時較容易發現。
- BIP39 讓助記詞成為一種「跨錢包通用的備份格式」。

#### BIP44：多幣種支持（Multi-Account Hierarchy）
- BIP44 基於 BIP32 和 BIP43，定義了一種多幣種錢包的規範。
- 它設計了「5層路徑結構」，讓一組助記詞可以管理多個幣種、多個帳戶，每個帳戶下又能擁有無數地址。
- 標準格式：`m / purpose' / coin_type' / account' / change / address_index`
    - `purpose'`: 固定為 44，代表使用 BIP44
    - `coin_type'`: 不同幣種有不同編號（如 BTC=0, ETH=60）
    - `account'`: 帳戶編號（0 開始）
    - `change`: 0 表示外部地址（收款地址），1 表示內部地址（找零地址）
    - `address_index`: 具體地址序號

### 2025.03.07

## BIP32, BIP39, BIP44
BIP（Bitcoin Improvement Proposal，Bitcoin改進提案）是提出Bitcoin新功能或改進的技術文件。任何人都可以提出BIP，經過社群審核並在bitcoin/bips上公佈。BIP就像Internet上的RFC（Request for Comments）一樣，是協議和技術進步的基礎文件。

BIP32、BIP39和BIP44是共同定義了目前廣泛使用的HD Wallet（層級確定性錢包，Hierarchical Deterministic Wallet）。它們不僅規範了錢包如何生成和管理密鑰，還包括設計理念、實作方式和具體實例。這些BIP的作用是提供一個標準化的方法來生成和管理加密貨幣錢包，方便使用者備份、恢復和管理多個密鑰。

### BIP32: Hierarchical Deterministic Wallet (HD Wallet)
BIP32定義了所謂的層級確定性錢包（Hierarchical Deterministic Wallet，簡稱“HD Wallet”），該系統允許從一個單一的“seed”（種子）生成一個樹狀結構，其中包含多組密鑰對（包括公鑰和私鑰）。這樣的設計使得用戶只需要記住一個單獨的seed即可管理多個密鑰對。

**優點**
- **方便備份和恢復**：用戶只需記住一個seed，而無需分別備份每個密鑰對。
- **遷移性**：可以將整個錢包的所有密鑰對安全地轉移到任何其他兼容裝置上，只需要提供這個seed。
- **層級權限控制**：可以將不同的密鑰對映射到樹結構的不同層級，從而實現多層的權限管理。

<img src="https://github.com/user-attachments/assets/17a1db46-8fa0-4420-8641-43c6cb2ec3c7" width="500" />

### BIP39: Mnemonic Code（助記詞）
BIP39提供了一個方便記憶的方式來表示BIP32中的seed。BIP39將原本的seed轉換成一組易於記憶的單詞，這組單詞通常由12個或24個單字組成，稱為助記詞（Mnemonic Phrase）。這樣的設計大大降低了用戶記憶和書寫的難度，並且更容易傳遞和備份。

**舉例**
假設助記詞是：
```
rose rocket invest real refuse margin festival danger anger border idle brown
```
這一組單詞就代表了某個特定的私鑰的生成seed。使用這些單詞可以推算出相對應的密鑰對。

#### 生成助記詞

- 一：生成128位隨機數
生成一個128位的隨機數。這個隨機數的目的是作為助記詞生成的基礎，確保每次生成的助記詞都是唯一且不可預測的。

  128位隨機數是一個長度為128位（即16字節）的數字，可以是0和1的隨機排列。例如：  
`1011001000110010101011001110110010011110100101101100100011010101`（這是一個範例，實際情況中會是完全隨機的）。

- 二：計算校驗碼
生成128位隨機數後，會基於該隨機數計算一個4位的校驗碼。這個校驗碼的計算方式是將隨機數的哈希值（使用SHA-256算法）進行處理，然後取哈希結果的前面4個位作為校驗碼。

  這個校驗碼的作用是增加錯誤檢查的機制。這樣，即使在存儲和輸入助記詞時發生錯誤，也可以檢查是否有錯誤發生。

- 三：合併隨機數與校驗碼
將128位的隨機數和4位的校驗碼組合在一起，這樣總長度是132位（128位隨機數 + 4位校驗碼）。

- 四：切分為11位長的區塊
將132位的數字按每11位切分。這樣就會得到12個11位的二進位數字。這些數字代表了在BIP39單詞表中對應的單詞。

- 五：查表生成助記詞
每個11位長的二進位數都對應一個BIP39單詞表中的單詞。BIP39單詞表通常包含2048個單詞。每個11位的二進位數字都會轉換為一個範圍在0到2047之間的數字，然後用這個數字查找BIP39單詞表中的單詞。

例如，假設某個11位的二進位數字是`00000000001`，對應的數字是1，查表後可能對應的單詞是「abandon」等。

- 六：生成12個助記詞

  你會得到12個單詞，這些單詞是根據隨機數生成的，並且包含了加強錯誤檢查的校驗碼。這12個單詞就是你所說的助記詞（Mnemonic Phrase），通常用於恢復錢包或保存私鑰。

![image](https://github.com/user-attachments/assets/077a9315-6854-41ad-ba95-b41b83741c97)


### BIP44: 多幣種、多帳戶支持
BIP44基於BIP32的設計，為HD Wallet的樹狀結構定義了每一層的特殊意義。這樣用戶可以使用同一個seed生成多個加密貨幣的錢包，支持多幣種和多帳戶管理。BIP44明確規範了錢包的路徑結構，將每一層的數字（稱為“硬分隔符”）賦予特定的意義。

**BIP44路徑結構：**
```
m / purpose' / coin_type' / account' / change / address_index
```
- **purpose'**：固定為44'，表明該路徑遵循BIP44標準。
- **coin_type'**：表示加密貨幣的類型。每個加密貨幣都有一個唯一的coin_type代碼。例如，比特幣的coin_type是0'，以太坊是60'。
- **account'**：表示錢包中的帳戶。每個帳戶可以有自己的密鑰對。
- **change**：用於區分普通地址和變更地址（通常是0和1，分別代表外部和內部地址）。
- **address_index**：表示具體的地址索引，每個地址對應一個唯一的索引。

### 以太坊的HD Wallet
以太坊的HD Wallet結構遵循BIP32和BIP44標準，並將coin_type設為60'，表示這個錢包是用來管理以太坊（ETH）資產的。在這種結構中，第一個帳戶的第一組密鑰對的路徑會是：
```
m/44'/60'/0'/0/0
```
這代表這是一個符合BIP44標準的以太坊錢包，並且是該錢包中第一個帳戶（account 0）下的第一個地址（address 0）。

### 創建以太坊HD Wallet的實作
在實現上，可以使用一些JavaScript庫來創建和管理以太坊的HD Wallet。常用的JavaScript套件包括：

- **bip39**：這個庫實現了BIP39標準，負責根據用戶提供的助記詞生成二進位的seed，並支持從seed生成對應的私鑰和公鑰。
  
- **ethereumjs-wallet**：這個庫提供了生成和管理以太坊密鑰對的功能，並且包含一個`hdkey`子套件來創建符合BIP32/BIP44標準的HD Wallet。

- **ethereumjs-util**（目前不需要）：這個庫包含許多以太坊特有的實用函數，例如加解密功能等。

參考：

[【加密貨幣錢包】從 BIP32、BIP39、BIP44 到 Ethereum HD Wallet](https://medium.com/taipei-ethereum-meetup/%E8%99%9B%E6%93%AC%E8%B2%A8%E5%B9%A3%E9%8C%A2%E5%8C%85-%E5%BE%9E-bip32-bip39-bip44-%E5%88%B0-ethereum-hd-%EF%BD%97allet-a40b1c87c1f7)

[2-Party BIP32：更安全的 HD-Wallet](https://blog.amis.com/2-party-bip32-%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84-hd-wallet-2d53a5f71545)

[DAY 28- BIP32- HD wallet](https://ithelp.ithome.com.tw/articles/10279944)

[HD Wallet](https://medium.com/@bun919tw/hd-wallet-970096a6d72f)

<!-- Content_END -->
